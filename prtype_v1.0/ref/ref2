2025/11/30 cortex調査

■起動処理と例外ベクタテーブル
・ROM上のプログラムを実行するタイプ
→マイコンリセットで定められたROM上のアドレスから実行．起動処理を配置しておく．
→Cortexの場合，ROM先頭に例外ベクタテーブルがあり，リセット時実行のアドレスが配置されている．
→リセット時に実行されるプログラムは例外ベクタテーブル
・RAM上に転送して実行するタイプ
→高性能マイコンに多くある．電源投入時RAMは消去されているため，ブートROM上のプログラムが実行され，
→外部記憶装置からRAMに転送される．

■例外と割り込み
特定イベント発生で割り込みし，ハンドラを実行するハードウェア機能．
C言語で書けないことが多く，アセンブリを使用したり，コンパイラ機能を用いる．

■例外ベクタテーブル
例外ハンドラの実行開始アドレスを設定したデータが例外ベクタテーブル．
cortexM0+先頭からのオフセットで順にスタックポインタ初期値，リセット，SVC，PendSV，Systickなどがある．
→PendSV,Systickなどを利用する．
CortexM0+はベクタテーブルの先頭項目はハンドラの実行アドレスではなく，リセット時設定のSP初期値になっている．

■起動処理について
先頭に16KのROMがある．工場出荷時設定のものでユーザ変更不可．例外ベクタテーブルやリセットハンドラが設定．
外部フラッシュメモリはXIP機能で通常ROM のようにアドレス空間にマップ．
外部フラッシュメモリの先頭256バイトはセカンドステージブートローダのプログラムが配置されている．
その後ろにユーザ定義例外ベクタテーブルとユーザプログラムを配置する．
ROMの例外ベクタテーブルと外部フラッシュメモリの例外ベクタテーブルは別物．
【1】ROM上のリセットハンドラ実行
リセット時，ファーストステージブートローダが実行．外部フラッシュメモリ先頭のセカンドブートステージローダをSRAM転送
【2】XIP設定
SRAMに転送されたセカンドステージブートローダではまず外部フラッシュ効率化のためXIPを設定．
【3】例外ベクタテーブルとユーザ定義リセットハンドラの実行
例外ベクタテーブルをROMのものからフラッシュメモリのユーザ定義のものに変更．
このときスタックポインタの設定を行う．続いてユーザー定義例外ベクタテーブルのリセットハンドラを実行
スタックポインタの設定やリセットハンドラは本来ハードウェア機能であるが，cortexM0+ではセカンドステージブートローダ．

■リンカスクリプト
プログラムはフラッシュに，変数はSRAMに．
セカンドステージブートローダなどやベクタテーブルも配置するアドレスが決められている．
実行コードはtext，グローバル変数はbss,またはdata
ソースコードで__attribute__でセクション名指定もできる．

■セカンドステージブートローダと例外ベクタテーブル
外部フラッシュのメモリのセカンドステージブートローダの後ろに例外ベクタテーブル（ユーザ定義）を配置する

■レジスタのアクセス関数
マイコン起動処理ではハードウェアの初期化を行うため，内蔵ペリフェラルのレジスタへのアクセスが行われる．
そのほかにもOSの処理としてレジスタにアクセスは使われるのでレジスタアクセス関数を作る．
ビットセット関数とビットクリア関数とビットXOR関数を作る

■割り込み制御関数について
割り込み受付と割り込み許可の関数を作成する．
CortexではPRIMASKレジスタによって割り込みの受付を制御できる．ただしこのレジスタはメモリ空間には
マップされておらず，専用のCPU命令でしかアクセスできない．→インラインアセンブリを用いる．
PRIMASKレジスタの値を変更するset_primask関数とレジスタの値を取得するget_primask関数を作成する．

■起動処理プログラムの作成
ユーザー定義のリセットハンドラについては，クロック初期化・ペリフェラル有効化・メモリセクション初期化
タイマの初期化・main関数の実行をする．詳細について．．．
1.クロックの初期化
picoで使用するのは水晶発振器XOSCで12MHzのクロックを生成する．
2.ペリフェラルの初期化
マイコンのペリフェラルは停止しているので必要なものを有効にする．
リセットcontrollerのRESETレジスタを設定して，使用するペリフェラルのリセットを解除する．
主にGPIOペリフェラルを有効化する．
3.メモリの初期化
初期化処理は，セクションbssに0を書き込み，セクションrodataの内容をdataにコピーする．
4.タイマの初期化
cortexではCPUコアごとSystickタイマを用意している．systickタイマは一定周期で割り込みを発生させる．
この周期はチックタイムと呼び，時間管理の単位時間とする．10msとする．
5.main関数の実行

マルチタスクについて P60～
■プログラムを並行に実行する方法
CPUは一度に一回のプログラムしか実行できないので，複数のプログラムを切り替えることで並列実行する．
実行プログラムの切り替えをディスパッチ，ディスパッチを行う内部プログラムがディスパッチャ

■プログラムを切り替える具体的方法
実行コンテキスト→CPUレジスタのデータとスタック．汎用レジスタ，スタックポインタ，リンクレジスタ，
プログラムカウンタ，ステータスレジスタなどがレジスタ
プログラムカウンタを変更しただけでは足りない．CPU状態は他のレジスタに格納されていることや，
計算中のデータは汎用レジスタに格納されているため．
レジスタでは処理しきれないデータはスタックに置かれている．
C言語では関数のローカル変数や，関数呼び出しの際退避した情報を記録するためにスタックを使っている．
SPスタックポインタはスタックの操作位置のアドレスが保持されている．

★ディスパッチャについて
ディスパッチャは実行コンテキストを次に事項するタスクの実行コンテキストに変更してタスクを切り替える．
それまでに実行していたタスクの情報を保存しておく必要がある．
実行コンテキストの情報を保存するのはタスクのスタックを利用する
SPレジスタの値はスタックそのものを差しているのでグローバル変数としてデータを保存．
タスクの数だけSPレジスタは存在するのでグローバル変数の配列となる．
コンテキスト・テーブルと呼ぶ．

★ディスパッチャ処理について AからBに切り替える場合
前提：タスクBのスタック上にはちゅだんじの実行コンテキスト情報が保存されている．このときスタックの
操作位置もコンテキストテーブルに保存されている．処理については，
・実行中タスクの実行コンテキストの保存．
各CPUレジスタの値を実行コンテキスト情報としてスタックに保存する．
・タスクのスタックの切り替え
SPレジスタの値をコンテキストテーブルに保存した後，テーブルに保存していたB用の値をSPレジスタに保存．
これによりスタックを切り替える．
・次実行のタスクの実行コンテキストの復元
タスクBのスタックから保存されているコンテキスト情報を各CPUレジスタに戻す．
これにより実行コンテキストはタスクBのものに切り替わった．

■タスク管理データ
コンテキストテーブルはctx_tblで定義（ポインタ配列）
現在実行中タスクはcur_task，次実行のタスクはnext_taskで作成．

■ディスパッチャの呼び出し
通常の関数として実装することも可能だが，ソフトウェア例外ハンドラとして実装するのが一般的．
ソフトウェア例外を使う利点について
・例外発生時，CPUレジスタがハード機能で自動でスタックに保存．R0-R3,R12,LR,PC,xPSRが退避．
ディスパッチャの呼び出しにPendSV例外が用意されている．割り込み制御ステータスICSR28bitに1各．

■    
  
  





































