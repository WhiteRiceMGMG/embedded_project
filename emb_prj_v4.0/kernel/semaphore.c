/* systimer.c                                           */
/********************************************************/
/* object    | システムタイマ                           */
/* abstract  | システムタイマ定義                       */
/* edit his  | 2025/12/23 テンプレート作成              */
/*           |                                          */
/********************************************************/
/********************************************************/
/* ヘッダーインクルード                                 */
/********************************************************/
#include <rpkernel.h>
#include <knldef.h> 

/********************************************************/
/* 内部公開マクロ                                       */
/********************************************************/
/* #define  u1g_SAMPLE_VAL                              */

/********************************************************/
/* 外部公開変数                                         */
/********************************************************/
/* u1 u1g_sample_val                                    */

/********************************************************/
/* 内部公開変数                                         */
/********************************************************/
TCB *wait_queue;

/********************************************************/
/* 外部公開関数定義                                     */
/********************************************************/

/********************************************************/
/* 関数   | void systimer_handler( void )               */
/* 説明   | シスタムタイマ割り込みハンドラ              */
/* 引数   | なし                                        */
/* 戻り値 | なし                                        */
/********************************************************/
void systimer_handler( void )
{
    TCB *tcb, *next;
    
    for(tcb = wait_queue; tcb != NULL; tcb = next)
    {
        next = tcb -> next;
        if(tcb -> waitim == TMO_FEVR)
        {
            continue;
        }
        else if(tcb -> waitime > TIMER_PERIOD)
        {
            tcb -> waitim -= TIMER_PERIOD;
        }
        else
        {
            tqueue_remove_enrty(&wait_queue, tcb);
            if(tcb -> waitfct = TWFCT_DLY)
            {
                *tcb -> waierr = E_OK;
            }
            else
            {
                *tcb -> waierr = E_TMOUT;
            }
            tcb -> state  = TS_READY;
            tcb -> waifct = TWFCT_NOW;
            tqueue_add_enrty(&ready_queue[tcb -> itspri], tcb);
       }
    }
    scheduler();
}

/********************************************************/
/* EOF                                                  */
/********************************************************/
